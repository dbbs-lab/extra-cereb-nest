import nest
import matplotlib.pylab as plt
import numpy as np
from itertools import accumulate
import trajectories

nest.Install("extracerebmodule")
nest.SetKernelStatus({'resolution': 1.0})


def cut_trial(evs, ts, i, norm_times=False):
    evts = zip(evs, ts)
    trial_evts = [
        (ev, t) for (ev, t) in evts
        if trial_len * i <= t < trial_len * (i + 1)
    ]
    if len(trial_evts) == 0:
        return [], []

    trial_evs, trial_ts = zip(*trial_evts)

    trial_evs = np.array(trial_evs)
    trial_ts = np.array(trial_ts)

    if norm_times:
        trial_ts -= trial_len * i

    return trial_evs, trial_ts


def integrate_joint(evs, ts, joint_coeff):
    j_evs = [0.0]
    j_ts = [0.0]

    for ev, t in zip(evs, ts):
        fiber_id = ev - pop_offset

        j_evs.append(fiber_id % pop_size)
        j_ts.append(t)
    torques = [2.0 * ev / pop_size - 1.0 for ev in j_evs]
    vel = np.array(list(accumulate(torques))) / pop_size
    pos = joint_coeff * np.array(list(accumulate(vel))) / pop_size

    return j_ts, torques, vel, pos


# SIMULATION PARAMETERS
n = 300  # Number of MFs
trial_len = 300  # [ms]
n_trial = 10  # Number of trials
target = 0.0  # [deg] final position of J1
prism = 25.0  # [deg] deviation generated by the prism
n_joints = 4  # Number of controlled joints
q_in = np.array((10.0, -10.0, -90.0, 170.0))  # [deg] Starting positions (initial joints)
q_fin = np.array((0.0, prism, 0.0, 0.0))  # [deg] Desired end positions (final joints)
trajectories.save_file(prism=prism, duration=trial_len)

# NEURON CREATION
planner = nest.Create(
    "planner_neuron",
    n=n,
    params={
        "trial_length": trial_len,
        "target": target,
        "prism_deviation": prism,
        "gain_rate": 0.03,
    }
)

cortex = nest.Create(
    "cortex_neuron",
    n=n,
    params={
        "trial_length": trial_len,
        "fibers_per_joint": n // n_joints,
        "rbf_sdev": 0.05 * n,
        "baseline_rate": 10.0,
    }
)

# NEURON CONNECTIONS
for i, neuron in enumerate(cortex):
    nest.SetStatus([neuron], {"joint_id": i // (n // n_joints),
                              "fiber_id": i % (n // n_joints)})

nest.Connect(planner, cortex, 'one_to_one')

# SPIKE DETECTORS CREATION AND CONNECTION
spike_detectors = nest.Create("spike_detector", n_joints)
cortex_sd = nest.Create("spike_detector")
planner_sd = nest.Create("spike_detector")
for j in range(n_joints):
    Pre = np.array(cortex)[np.where(np.array(nest.GetStatus(cortex, "joint_id")) == j)]
    Post = np.array([spike_detectors[j]])
    nest.Connect(Pre, Post, "all_to_all")
nest.Connect(cortex, cortex_sd)
nest.Connect(planner, planner_sd)

# SIMULATION (Trial by trial)
for trial in range(n_trial):
    nest.Simulate(trial_len)

# INTEGRATION OF THE MOTOR CORTEX ACTIVITY (Joint by joint and trial by trial)
tor_traj = np.loadtxt("JointTorques.dat")
joint_coeff = tor_traj[0, :] * 2000.0
joint_states = []
xss = []
x_mean = np.empty(4)
x_std = np.empty(4)
for j in range(n_joints):
    pop_size = np.sum(np.array(nest.GetStatus(cortex, "joint_id")) == j)
    pop_offset = np.min(np.array(cortex)[np.where(np.array(nest.GetStatus(cortex, "joint_id")) == j)])
    dSD = nest.GetStatus([spike_detectors[j]], keys="events")[0]
    evs = dSD["senders"]
    ts = dSD["times"]
    print("Mean firing rate for joint " + str(j) + " is " + str(1000 * np.size(ts) / (pop_size * n_trial * trial_len)))
    joint_state = []  # (ts, qdd, qd, q) * n_trials
    xs = []  # position final value [deg]

    for i in range(n_trial):
        trial_evs, trial_ts = cut_trial(evs, ts, i)
        q_ts, qdd, qd, q = integrate_joint(trial_evs, trial_ts, joint_coeff[j])
        q += q_in[j]
        if len(q) > 0:
            xs.append(q[-1])

        if joint_state == []:
            joint_state = np.array([q_ts, qdd, qd, q])
        else:
            joint_state = np.column_stack([joint_state, [q_ts, qdd, qd, q]])

    joint_states.append(joint_state)
    xss.append(xs)
    x_mean[j] = np.mean(xs)
    x_std[j] = np.std(xs)

for j in range(n_joints):
    print("Joints %i positions: %4.2f +- %4.2f (Ideal: %4.2f)" % (j, x_mean[j], x_std[j], q_fin[j]))

# PLOTS
fig, axs = plt.subplots(3, n_joints)
for j in range(n_joints):
    q_ts, qdd, qd, q = joint_states[j]
    axs[0, j].plot(q_ts, q, '.')
    axs[0, j].set_ylabel("Joint position [deg]")
    axs[1, j].plot(q_ts, qd, '.')
    axs[1, j].set_ylabel("Joint velocity [A.U.]")
    axs[2, j].plot(q_ts, qdd, '.')
    axs[2, j].set_ylabel("Joint torque [A.U.]")
    axs[2, j].set_xlabel("Time [ms]")

fig, axs = plt.subplots(1, n_joints)
for j in range(n_joints):
    q_ts, qdd, qd, q = joint_states[j]
    axs[j].plot(range(n_trial), xss[j])
    axs[j].set_xlabel("Trial #")
    axs[j].set_ylabel("Joint %i end position [deg]" % j)

fig, axs = plt.subplots(2)

dSD = nest.GetStatus(cortex_sd, keys="events")[0]
evs = dSD["senders"]
ts = dSD["times"]

axs[0].scatter(ts, evs, marker='.')
axs[0].set_xlabel("Time [ms]")
axs[0].set_ylabel("Neuron ID (Cortex)")

dSD = nest.GetStatus(planner_sd, keys="events")[0]
evs = dSD["senders"]
ts = dSD["times"]

axs[1].scatter(ts, evs, marker='.')
axs[1].set_xlabel("Time [ms]")
axs[1].set_ylabel("Neuron ID (Planner)")

plt.show()
