import nest
import matplotlib.pylab as plt
import numpy as np
from itertools import accumulate

nest.Install("extracerebmodule")
nest.SetKernelStatus({'resolution': 1.0})


def cut_trial(evs, ts, i, norm_times=False):
    evts = zip(evs, ts)
    trial_evts = [
        (ev, t) for (ev, t) in evts
        if trial_len*i <= t < trial_len*(i+1)
    ]
    if len(trial_evts) == 0:
        return [], []

    trial_evs, trial_ts = zip(*trial_evts)

    trial_evs = np.array(trial_evs)
    trial_ts = np.array(trial_ts)

    if norm_times:
        trial_ts -= trial_len*i

    return trial_evs, trial_ts


def integrate_joint(evs, ts):
    j_evs = []
    j_ts = []

    for ev, t in zip(evs, ts):
        fiber_id = ev - pop_offset - 1

        j_evs.append(fiber_id % pop_size)
        j_ts.append(t)

    torques = [2.0*ev / pop_size - 1.0 for ev in j_evs]
    vel = np.array(list(accumulate(torques))) / pop_size
    pos = np.array(list(accumulate(vel))) / pop_size

    return j_ts, torques, vel, pos


n = 300  # Number of MFs
trial_len = 300  # [ms]
n_trial = 20  # Number of trials
target = 0.0  # [deg] final position of J1
prism = 0.0  # [deg] deviation generated by the prism
n_joints = 4  # Number of controlled joints

planner = nest.Create(
        "planner_neuron",
        n=n,
        params={
            "trial_length": trial_len,
            "target": target,
            "prism_deviation": prism,
            "gain_rate": 10.0,
            }
        )

cortex = nest.Create(
        "cortex_neuron",
        n=n,
        params={
            "trial_length": trial_len,
            "fibers_per_joint": n//4,
            "rbf_sdev": 15.0,
            "baseline_rate": 10.0,
            }
        )

for i, neuron in enumerate(cortex):
    nest.SetStatus([neuron], {"joint_id": i // (n//4),
                              "fiber_id": i % (n//4)})

nest.Connect(planner, cortex, 'one_to_one')

spike_detectors = nest.Create("spike_detector", 4)
for j in range(n_joints):
    Pre = np.array(cortex)[np.where(np.array(nest.GetStatus(cortex, "joint_id")) == j)]
    Post = np.array([spike_detectors[j]])
    nest.Connect(Pre, Post, "all_to_all")

for trial in range(n_trial):
    nest.Simulate(trial_len)

joint_states = []
for j in range(n_joints):
    dSD = nest.GetStatus([spike_detectors[j]], keys="events")[0]
    evs = dSD["senders"]
    ts = dSD["times"]

    joint_state = []  # (ts, qdd, qd, q) * n_trials
    xs = []  # position final value

    for i in range(n_trial):
        trial_evs, trial_ts = cut_trial(evs, ts, i)
        pop_size = np.sum(np.array(nest.GetStatus(cortex, "joint_id")) == j)
        pop_offset = np.min(np.array(cortex)[np.where(np.array(nest.GetStatus(cortex, "joint_id")) == j)])
        q_ts, qdd, qd, q = integrate_joint(trial_evs, trial_ts)
        if len(q) > 0:
            xs.append(q[-1])

        if joint_state == []:
            joint_state = np.array([q_ts, qdd, qd, q])
        else:
            joint_state = np.column_stack([joint_state, [q_ts, qdd, qd, q]])

    joint_states.append(joint_state)
    x_mean = np.mean(xs)
    x_std = np.std(xs)

fig, axs = plt.subplots(3, 4)
for j in range(n_joints):
    q_ts, qdd, qd, q = joint_states[j]
    axs[0, j].plot(q_ts, q)
    axs[1, j].plot(q_ts, qd)
    axs[2, j].plot(q_ts, qdd)

plt.show()
